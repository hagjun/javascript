<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>map, some, every, filter, reduce</title>
</head>
<body>
<script type="text/javascript">
<!-- map : 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환 -->
	const numbers = [1, 4, 9, 16];
//	const result = numbers.map(콜백);

	const result = numbers.map(function(num) {
		// 배열의 각 요소 마다 *2를 한다.
		return num * 2;
	});	
	console.log(result);
	
	/* 한개 씩 넘어오면 */
	/* 이때 num은 numbers 배열의 각각의 요소를 말한다. */
	const result2 = numbers.map((num)=> num *2);
	console.log(result2);
	
	/* 클래스 생성시 무조건 생성자(constructor) 필요 */
	// 현실에서는 DB정보 또는 제공하는 정보가 객체인 경우가 많다.
	class Student{
		constructor(name, kor, eng, math){
			this.name = name;
			this.kor = kor;
			this.eng = eng;
			this.math = math;
			
		}
	}
	
	const student1 = new Student('홍길동', 95, 87, 75);
	const student2 = new Student('김길동', 67, 80, 100);
	const student3 = new Student('고길동', 89, 75, 80);
	const student4 = new Student('최길동', 48, 52, 98);
	
	const students = [student1, student2, student3, student4];
	
	console.log("영어점수 : ", students.map((student)=>student.eng));
	
	/* some(or조건) : 배열 안에서 주어진 조건을 하나라도 만족하면 true */
	console.log("숫자가 7이상인 숫자가 있나요? : ", numbers.some((num)=> num>=7));
	console.log("수학점수가 100점인 학생이 있나요? : ", students.some((k)=>k.math === 100));
	console.log("영어점수가 50점미만인 학생이 있나요? : ", students.some((k)=>k.eng < 50));
	
	/* every(and조건) : 배열안의 모든 요소가 주어진 조건을 만족하면 true */
	console.log("숫자가 7이상 인가요? : ", numbers.every((num)=> num>=7));
	console.log("수학점수가 70점 이상인가요? : ", students.every((k)=>k.math >= 70));
	
	/* filter : 배열의 요소 중 주어진 조건에 만족하는 요소들만 새로운 배열로 반환 */
	console.log("숫자 중 홀수만 출력하기 : ", numbers.filter((num)=> num%2===1));
	console.log("영어점수가 80점 이상인 학생만 출력하기 : ", students.filter((k)=>k.eng >= 80));
	
	/* reduce : 배열의 각 요소에 주어진 리듀서 함수를 실행하고 하나의 결과값을 반환
		        주로 누적합, 중복제거에 사용 된다.
		        
	리듀서 함수 : acc(누적값), cur(현재값), idx(현재인덱스), src(원본배열)
	
	배열.reduce((acc, cur, index, src)=>{
		내용
	return 리턴값}, 초기값);
	
	리턴값이 acc로 다시 들어간다.
	*/
	
	const numbers2 = [1, 4, 9, 16];
	numbers2.reduce((acc, cur, index, src)=>{
		console.log(`acc:${acc}, cur:${cur}, index:${index}, src:${src}`);
		return acc}, 0);
	
	console.log("===============================");
	numbers2.reduce((acc, cur, index, src)=>{
		console.log(`acc:${acc}, cur:${cur}, index:${index}, src:${src}`);
		return acc}, 1);
	
	console.log("===============================");
	numbers2.reduce((acc, cur, index, src)=>{
		 console.log(`acc:${acc}, cur:${cur}, index:${index}, src:${src}`);
		 return acc + cur}, 0); /* 누적값 구하기 : return acc + cur */

	/* 누적값 구하기 */
	console.log("===============================");
	const result3 = numbers2.reduce((acc, cur, index, src)=>{
		            return acc + cur}, 0); /* 누적값 구하기 : return acc + cur */
	console.log("결과 : " + result3);
	console.log("===============================");
	
	/* 중복 제거 */
	const fluits = ["사과", "딸기", "배", "참외", "딸기", "수박"];
	
	// 비어있는 배열에서 includes(현재값)를 이용해서 중복제거
	console.log(fluits);
	const result4 = fluits.reduce((acc, cur)=>{ // 누적합
		// includes() 메서드는 배열의 항목에 특정 값이 포함되어 있는지를 판단하여 적절히 true 또는 false를 반환
		if(acc.includes(cur) === false){ // 현재값이랑 비교(같지 않다면)
			// 배열에 넣기(push)
			acc.push(cur); // 현재꺼를 집어 넣어주세요.
		}
		return acc;
	},[])

		
		
	console.log(result4);
	
</script>
</body>
</html>